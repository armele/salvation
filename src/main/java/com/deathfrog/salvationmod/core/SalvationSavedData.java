package com.deathfrog.salvationmod.core;

import java.util.HashMap;
import java.util.Map;

import javax.annotation.Nonnull;

import com.deathfrog.salvationmod.core.colony.ColonyHandlerState;
import com.minecolonies.api.colony.IColony;

import net.minecraft.core.HolderLookup.Provider;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.saveddata.SavedData;

public final class SalvationSavedData extends SavedData
{
    private final Map<String, ColonyHandlerState> colonyStates = new HashMap<>();
    private static final String TAG_COLONIES = "colonies";
    private static final String TAG_LAST_EVAL = "lastEval";
    public static final String NAME = "salvation_savedata";

    private long lastLoopGameTime = 0L;

    /**
     * Returns the SalvationSavedData associated with the given level.
     * If no such data exists, a new instance is created and stored in the data storage.
     * @param level the level to get the SalvationSavedData for
     * @return the SalvationSavedData associated with the given level, or a new one if none exists
     */
    public static SalvationSavedData get(ServerLevel level) 
    {
        return level.getDataStorage().computeIfAbsent(
            new Factory<>(SalvationSavedData::new, SalvationSavedData::load),
            NAME
        );
    }

    /**
     * Returns the colony state for the given key, or creates a new one if it doesn't exist.
     * This is a convenience method that wraps the computeIfAbsent method of the Map.
     * @param key the key of the colony to get the state for, generated by the colonyKey method
     * @return the colony state for the given key, or a new one if it doesn't exist
     */
    public ColonyHandlerState getOrCreateColonyState(String key)
    {
        return colonyStates.computeIfAbsent(key, k -> new ColonyHandlerState());
    }

    /**
     * Updates the colony state for the given key with the given state.
     * This should be called whenever the colony state is updated.
     * @param key the key of the colony to update, generated by the colonyKey method
     * @param state the new state of the colony
     */
    public void updateColonyState(String key, ColonyHandlerState state)
    {
        colonyStates.put(key, state);
        setDirty();
    }

    /**
     * Returns a unique key for the given colony and level.
     * This key is in the format of "dimension:colony_center".
     * @param level the level to generate the key for
     * @param colony the colony to generate the key for
     * @return the unique key for the given colony and level
     */
    public static String colonyKey(Level level, IColony colony)
    {
        return level.dimension().location() + ":" + colony.getCenter().asLong();
    }

    /**
     * Loads the Salvation saved data from the given compound tag.
     * This method is called by the data storage system when the data is loaded.
     * It should deserialize the entire state of the Salvation saved data from the given compound tag.
     * @param tag the compound tag to load the data from
     * @param registries the provider for the registries
     * @return the loaded Salvation saved data
     */
    public static SalvationSavedData load(CompoundTag tag, Provider registries) {
        SalvationSavedData data = new SalvationSavedData();
        data.lastLoopGameTime = tag.getLong(TAG_LAST_EVAL);

        CompoundTag coloniesTag = tag.getCompound(TAG_COLONIES);

        for (String key : coloniesTag.getAllKeys())
        {
            if (key == null) continue;

            data.colonyStates.put(key, ColonyHandlerState.fromTag(coloniesTag.getCompound(key)));
        }

        return data;
    }

    /**
     * Saves the current state of the Salvation saved data to the given compound tag.
     * This method is called by the data storage system when the data is saved.
     * It should serialize the entire state of the Salvation saved data into the given compound tag.
     * @param tag the compound tag to save the data to
     * @param registries the provider for the registries
     * @return the saved compound tag
     */
    @Override
    public CompoundTag save(@Nonnull CompoundTag tag, @Nonnull Provider registries)
    {
        CompoundTag coloniesTag = new CompoundTag();
        for (Map.Entry<String, ColonyHandlerState> e : colonyStates.entrySet())
        {
            String key = e.getKey();
            CompoundTag colonyTag = e.getValue().toTag();

            if (key == null || colonyTag == null) continue;

            coloniesTag.put(key, colonyTag);
        }
        tag.put(TAG_COLONIES, coloniesTag);

        tag.putLong(TAG_LAST_EVAL, lastLoopGameTime);
        return tag;
    }

    /**
     * Returns the last loop game time of the Salvation saved data.
     * This is the last time in game ticks that the Salvation saved data was updated.
     * @return the last loop game time of the Salvation saved data
     */
    public long setLastLoopGameTime()
    {
        return lastLoopGameTime;
    }

    /**
     * Sets the last loop game time of the Salvation saved data.
     * This is the last time in game ticks that the Salvation saved data was updated.
     * Calling this method will mark the data as dirty, so that it will be saved to disk.
     * @param t the new last loop game time of the Salvation saved data
     */
    public void setLastLoopGameTime(long t)
    {
        lastLoopGameTime = t;
        setDirty();
    }
}
